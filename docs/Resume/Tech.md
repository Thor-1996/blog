## React

### hooks

类组件缺陷:

- 代码笨重
- 组件难拆分,重构及测试
- 业务逻辑复用不便
- 类组件引入了复杂的编成方式, 高阶组件

函数组件没有状态和生命周期, 无法取代类组件

hooks 的设计是加强函数组件, 不使用类也可以写出一个全功能的组件

### 高阶组件

参数为组件, 返回值为新组件的函数

将可复用的逻辑与 UI 分离, 在不破坏原有组件功能的同时,增强原有组件

### 原理

React 是用于快速构建用户界面的 js 库

### other

1. 列表组件 key 的作用

2. setState

3.

### React 事件机制

## webpack && vite

1. 动态主题

2. 懒加载

### 脚手架

## 浏览器

1. async vs defer

### 事件循环

## 工程化

- 开发效率

  自动化

      - 分支管理规范
      - 代码格式, 代码规范
      - 自动化测试
      - 持续集成(CI)
      - 持续部署(CD)

- 协作效率

- 系统质量

  可读性, 可维护性, 稳定性

  - 设计严谨的需求

    需求理解清晰, 考虑周全

  - 设计严谨的方案

    技术方案合理, 实现考虑可用性, 兼容性, 扩展性, 性能等方面,避免过度设计
    架构设计
    技术栈选用合理, 符合系统需要, 生态完善, 开发人员上手容易或者有经验
    模块拆分合理, 符合高内聚低耦合模型, 重复逻辑抽象封装

  - 严格的测试

    不同环境(开发,测试,预发布,生产)测试的一致性
    单元测试
    自动化测试

  - 完善的文档

    人员变动, 技术迭代更新需要在当前记录一份简洁, 可靠的文档

  - 完善的监控系统

    异常监控告警, 性能报告

## 其他

1. 首屏时间优化

   1. http 缓存
   2. cdn
   3. 按需加载
   4. 资源压缩
   5. http 2.0

## JSBridge

原生与 Webview 通信的桥梁, 让原生可以调用 JS, JS 可以调用原生

### JS 调用 Native

1. 拦截 URL Scheme

URL Scheme 是一种类似 url 的链接,是为了方便 App 互相调用而设计的

2. Native 重写原生 JS 方法

3. 注入 API

通过 Webview 提供的接口, 像 Window 注入对象或方法

## Native 调用 JS

执行 拼接好的 JS 代码

## 虚拟长列表

## Webpack

## monorepo

### 概念

Monorepo 架构是指将所有项目代码存储在单个代码库中的架构，相对于多个代码库(多个仓库）的多仓库架构来说。 Monorepo 架构可以帮助开发人员更好地管理项目的依赖关系，更好地协作和共享代码，更好地维护和更新项目中的库和工具。

Monorepo 通常使用工具来管理项目之间的依赖关系，如 Lerna, Yarn workspace 等。使用这种架构，开发人员可以在不同的项目之间共享代码，并可以在一个地方管理和维护所有项目的库和工具。

### 优势

1. 代码共享和复用：在单个仓库中维护所有项目代码，可以方便地在项目之间共享和复用代码
2. 依赖管理：将所有项目的依赖关系统一管理，可以避免版本冲突和不兼容性问题
3. 协作和团队协作：在单个仓库中维护所有项目，可以更好地协调团队成员之间的工作，并且更容易管理代码审核和合并
4. 统一的工具和流程：在单个仓库中维护所有项目，可以使用相同的工具和流程来管理所有项目，减少开发人员的学习成本
5. 更好的可维护性：在单个仓库中维护所有项目，可以更好地维护项目的整体结构和组件之间的关系，减少项目的维护成本

### 劣势

1. 大型项目管理难度：对于大型项目，单个仓库中存储所有代码可能会导致管理和维护难度增加。
2. 长时间的构建和部署时间：由于所有项目都存储在单个仓库中，因此构建和部署所有项目可能需要较长时间。
3. 难以隔离问题：如果单个项目出现问题，可能会影响整个仓库中的其他项目。
4. 更高的学习成本：使用 Monorepo 架构可能需要学习新的工具和流程，这可能会增加开发人员的学习成本。

### 解决了什么问题

Monorepo 架构可以解决多个项目之间的依赖关系管理问题。在传统的多仓库架构中，每个项目都是一个单独的仓库，这意味着在不同项目之间进行依赖关系管理非常困难。而在 Monorepo 架构中，所有项目都在一个仓库中管理，这使得依赖关系管理变得简单明了。此外，Monorepo 架构还可以帮助提高团队协作效率和代码的可维护性。
